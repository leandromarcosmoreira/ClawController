{"$message_type":"diagnostic","message":"cannot find type `SqlitePool` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":648,"byte_end":658,"line_start":32,"line_end":32,"column_start":11,"column_end":21,"is_primary":true,"text":[{"text":"    pool: SqlitePool,","highlight_start":11,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this type alias","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::SqlitePool;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `SqlitePool` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:32:11\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pool: SqlitePool,\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this type alias\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::SqlitePool;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Router`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1017,"byte_end":1023,"line_start":46,"line_end":46,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    let app = Router::new()","highlight_start":15,"highlight_end":21}],"label":"use of undeclared type `Router`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Router;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Router`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:46:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let app = Router::new()\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `Router`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Router;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1051,"byte_end":1054,"line_start":47,"line_end":47,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        .route(\"/\", get(root))","highlight_start":21,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:47:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .route(\"/\", get(root))\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1084,"byte_end":1087,"line_start":48,"line_end":48,"column_start":23,"column_end":26,"is_primary":true,"text":[{"text":"        .route(\"/ws\", get(ws_handler))","highlight_start":23,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:48:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0me(\"/ws\", get(ws_handler))\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1127,"byte_end":1130,"line_start":49,"line_end":49,"column_start":27,"column_end":30,"is_primary":true,"text":[{"text":"        .route(\"/agents\", get(get_agents).post(create_agent))","highlight_start":27,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:49:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0magents\", get(get_agents).p\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1193,"byte_end":1196,"line_start":50,"line_end":50,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"        .route(\"/agents/:id\", get(get_agent).put(update_agent).delete(delete_agent))","highlight_start":31,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:50:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mts/:id\", get(get_agent).pu\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1273,"byte_end":1276,"line_start":51,"line_end":51,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"        .route(\"/tasks\", get(get_tasks).post(create_task))","highlight_start":26,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:51:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m/tasks\", get(get_tasks).po\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1336,"byte_end":1339,"line_start":52,"line_end":52,"column_start":30,"column_end":33,"is_primary":true,"text":[{"text":"        .route(\"/tasks/:id\", get(get_task).put(update_task).delete(delete_task))","highlight_start":30,"highlight_end":33}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:52:30\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mks/:id\", get(get_task).put\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1426,"byte_end":1429,"line_start":53,"line_end":53,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"        .route(\"/tasks/:id/comments\", get(get_comments).post(create_comment))","highlight_start":39,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:53:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mmments\", get(get_comments)\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1499,"byte_end":1502,"line_start":54,"line_end":54,"column_start":34,"column_end":37,"is_primary":true,"text":[{"text":"        .route(\"/announcements\", get(get_announcements).post(create_announcement))","highlight_start":34,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:54:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mements\", get(get_announcem\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1577,"byte_end":1580,"line_start":55,"line_end":55,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"        .route(\"/activity\", get(get_activity))","highlight_start":29,"highlight_end":32}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:55:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtivity\", get(get_activity))\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1634,"byte_end":1637,"line_start":56,"line_end":56,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"        .route(\"/tasks/:id/activity\", get(get_task_activity).post(add_task_activity))","highlight_start":39,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:56:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtivity\", get(get_task_acti\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1707,"byte_end":1710,"line_start":57,"line_end":57,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"        .route(\"/stats\", get(get_stats))","highlight_start":26,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::routing::get;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:57:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m/stats\", get(get_stats))\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this function\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::routing::get;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `CorsLayer`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1738,"byte_end":1747,"line_start":58,"line_end":58,"column_start":16,"column_end":25,"is_primary":true,"text":[{"text":"        .layer(CorsLayer::permissive())","highlight_start":16,"highlight_end":25}],"label":"use of undeclared type `CorsLayer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tower_http::cors::CorsLayer;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `CorsLayer`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:58:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m.layer(CorsLayer::permissi\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `CorsLayer`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use tower_http::cors::CorsLayer;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `SocketAddr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2234,"byte_end":2244,"line_start":72,"line_end":72,"column_start":16,"column_end":26,"is_primary":true,"text":[{"text":"    let addr = SocketAddr::from(([0, 0, 0, 0], 8000));","highlight_start":16,"highlight_end":26}],"label":"use of undeclared type `SocketAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::net::SocketAddr;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::os::unix::net::SocketAddr;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::net::SocketAddr;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tokio::net::unix::SocketAddr;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `SocketAddr`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:72:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0maddr = SocketAddr::from(([\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `SocketAddr`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use std::net::SocketAddr;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use std::os::unix::net::SocketAddr;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use core::net::SocketAddr;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use tokio::net::unix::SocketAddr;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2567,"byte_end":2572,"line_start":86,"line_end":86,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:86:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<A\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2581,"byte_end":2586,"line_start":86,"line_end":86,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:86:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m(state): State<Arc<AppStat\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3191,"byte_end":3196,"line_start":109,"line_end":109,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:109:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3205,"byte_end":3210,"line_start":109,"line_end":109,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:109:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3239,"byte_end":3243,"line_start":110,"line_end":110,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Agent>>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:110:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Vec<Agent>>\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Agent` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3248,"byte_end":3253,"line_start":110,"line_end":110,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Agent>>, (StatusCode, String)> {","highlight_start":22,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Agent;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Agent` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:110:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mon<Vec<Agent>>, (StatusCo\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Agent;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3258,"byte_end":3268,"line_start":110,"line_end":110,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Agent>>, (StatusCode, String)> {","highlight_start":32,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3258,"byte_end":3268,"line_start":110,"line_end":110,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Agent>>, (StatusCode, String)> {","highlight_start":32,"highlight_end":42}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":3258,"byte_end":3268,"line_start":110,"line_end":110,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Agent>>, (StatusCode, String)> {","highlight_start":32,"highlight_end":42}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3185,"byte_end":3185,"line_start":108,"line_end":108,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"async fn get_agents(","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:110:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m>>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Agent>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m110\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Agent>>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Agent>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m110\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Agent>>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_agents\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Agent` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3318,"byte_end":3323,"line_start":111,"line_end":111,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"    let agents = sqlx::query_as::<_, Agent>(","highlight_start":38,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Agent;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Agent` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:111:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0ms::<_, Agent>(\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Agent;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3620,"byte_end":3624,"line_start":118,"line_end":118,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(agents))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:118:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(agents))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3689,"byte_end":3694,"line_start":123,"line_end":123,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:123:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3703,"byte_end":3708,"line_start":123,"line_end":123,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:123:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3737,"byte_end":3741,"line_start":124,"line_end":124,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:124:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Agent>, (St\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Agent` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3742,"byte_end":3747,"line_start":124,"line_end":124,"column_start":18,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":18,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Agent;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Agent` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:124:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt<Json<Agent>, (StatusCod\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Agent;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3751,"byte_end":3761,"line_start":124,"line_end":124,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3751,"byte_end":3761,"line_start":124,"line_end":124,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":3751,"byte_end":3761,"line_start":124,"line_end":124,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3655,"byte_end":3655,"line_start":121,"line_end":121,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"async fn get_agent(","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:124:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Agent>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m124\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Agent>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Agent>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m124\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Agent>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_agent\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Agent` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3810,"byte_end":3815,"line_start":125,"line_end":125,"column_start":37,"column_end":42,"is_primary":true,"text":[{"text":"    let agent = sqlx::query_as::<_, Agent>(","highlight_start":37,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Agent;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Agent` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:125:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0ms::<_, Agent>(\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Agent;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4127,"byte_end":4131,"line_start":133,"line_end":133,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(agent))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:133:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(agent))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4170,"byte_end":4175,"line_start":137,"line_end":137,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:137:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4210,"byte_end":4214,"line_start":138,"line_end":138,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:138:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m138\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4184,"byte_end":4189,"line_start":137,"line_end":137,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:137:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4225,"byte_end":4229,"line_start":138,"line_end":138,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:138:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m138\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4262,"byte_end":4266,"line_start":139,"line_end":139,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:139:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Agent>, (St\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Agent` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4267,"byte_end":4272,"line_start":139,"line_end":139,"column_start":18,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":18,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Agent;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Agent` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:139:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt<Json<Agent>, (StatusCod\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Agent;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4276,"byte_end":4286,"line_start":139,"line_end":139,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4276,"byte_end":4286,"line_start":139,"line_end":139,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":4276,"byte_end":4286,"line_start":139,"line_end":139,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4164,"byte_end":4164,"line_start":136,"line_end":136,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn create_agent(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:139:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Agent>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m139\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Agent>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Agent>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m139\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Agent>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn create_agent\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4756,"byte_end":4761,"line_start":151,"line_end":151,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"    get_agent(Path(id), State(state)).await","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4756,"byte_end":4761,"line_start":151,"line_end":151,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"    get_agent(Path(id), State(state)).await","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":"state","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:151:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m151\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mPath(id), State(state)).a\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a local variable with a similar name exists (notice the capitalization)\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m151\u001b[0m \u001b[91m- \u001b[0m    get_agent(Path(id), \u001b[91mState\u001b[0m(state)).await\n\u001b[1m\u001b[94m151\u001b[0m \u001b[92m+ \u001b[0m    get_agent(Path(id), \u001b[92mstate\u001b[0m(state)).await\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4834,"byte_end":4839,"line_start":156,"line_end":156,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:156:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4874,"byte_end":4878,"line_start":157,"line_end":157,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:157:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4848,"byte_end":4853,"line_start":156,"line_end":156,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:156:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4889,"byte_end":4893,"line_start":157,"line_end":157,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:157:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4926,"byte_end":4930,"line_start":158,"line_end":158,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:158:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Agent>, (St\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Agent` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4931,"byte_end":4936,"line_start":158,"line_end":158,"column_start":18,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":18,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Agent;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Agent` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:158:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt<Json<Agent>, (StatusCod\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Agent;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4940,"byte_end":4950,"line_start":158,"line_end":158,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4940,"byte_end":4950,"line_start":158,"line_end":158,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":4940,"byte_end":4950,"line_start":158,"line_end":158,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":") -> Result<Json<Agent>, (StatusCode, String)> {","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4800,"byte_end":4800,"line_start":154,"line_end":154,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn update_agent(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:158:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Agent>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m158\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Agent>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Agent>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m158\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Agent>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m154\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn update_agent\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5299,"byte_end":5304,"line_start":168,"line_end":168,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"    get_agent(Path(id), State(state)).await","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5299,"byte_end":5304,"line_start":168,"line_end":168,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"    get_agent(Path(id), State(state)).await","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":"state","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:168:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mPath(id), State(state)).a\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a local variable with a similar name exists (notice the capitalization)\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[91m- \u001b[0m    get_agent(Path(id), \u001b[91mState\u001b[0m(state)).await\n\u001b[1m\u001b[94m168\u001b[0m \u001b[92m+ \u001b[0m    get_agent(Path(id), \u001b[92mstate\u001b[0m(state)).await\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5377,"byte_end":5382,"line_start":173,"line_end":173,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:173:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m173\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5391,"byte_end":5396,"line_start":173,"line_end":173,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:173:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m173\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5425,"byte_end":5435,"line_start":174,"line_end":174,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":13,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5425,"byte_end":5435,"line_start":174,"line_end":174,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":5425,"byte_end":5435,"line_start":174,"line_end":174,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5343,"byte_end":5343,"line_start":171,"line_end":171,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn delete_agent(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:174:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0msult<StatusCode, (StatusC\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[91m- \u001b[0m) -> Result<\u001b[91mStatusCode\u001b[0m, (StatusCode, String)> {\n\u001b[1m\u001b[94m174\u001b[0m \u001b[92m+ \u001b[0m) -> Result<\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[91m- \u001b[0m) -> Result<\u001b[91mStatusCode\u001b[0m, (StatusCode, String)> {\n\u001b[1m\u001b[94m174\u001b[0m \u001b[92m+ \u001b[0m) -> Result<\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m171\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn delete_agent\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5438,"byte_end":5448,"line_start":174,"line_end":174,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5438,"byte_end":5448,"line_start":174,"line_end":174,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":5438,"byte_end":5448,"line_start":174,"line_end":174,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5343,"byte_end":5343,"line_start":171,"line_end":171,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn delete_agent(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:174:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mde, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[91m- \u001b[0m) -> Result<StatusCode, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m174\u001b[0m \u001b[92m+ \u001b[0m) -> Result<StatusCode, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[91m- \u001b[0m) -> Result<StatusCode, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m174\u001b[0m \u001b[92m+ \u001b[0m) -> Result<StatusCode, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m171\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn delete_agent\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5709,"byte_end":5714,"line_start":185,"line_end":185,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:185:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5723,"byte_end":5728,"line_start":185,"line_end":185,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:185:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5757,"byte_end":5761,"line_start":186,"line_end":186,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Task>>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:186:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Vec<Task>>,\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Task` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5766,"byte_end":5770,"line_start":186,"line_end":186,"column_start":22,"column_end":26,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Task>>, (StatusCode, String)> {","highlight_start":22,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Task;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Task` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:186:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mJson<Vec<Task>>, (StatusC\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Task;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5775,"byte_end":5785,"line_start":186,"line_end":186,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Task>>, (StatusCode, String)> {","highlight_start":31,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5775,"byte_end":5785,"line_start":186,"line_end":186,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Task>>, (StatusCode, String)> {","highlight_start":31,"highlight_end":41}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":5775,"byte_end":5785,"line_start":186,"line_end":186,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Task>>, (StatusCode, String)> {","highlight_start":31,"highlight_end":41}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5703,"byte_end":5703,"line_start":184,"line_end":184,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"async fn get_tasks(","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:186:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m>>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m186\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Task>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m186\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Task>>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m186\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Task>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m186\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Task>>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_tasks\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Task` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5834,"byte_end":5838,"line_start":187,"line_end":187,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    let tasks = sqlx::query_as::<_, Task>(","highlight_start":37,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Task;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Task` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:187:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m187\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_as::<_, Task>(\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Task;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6108,"byte_end":6112,"line_start":194,"line_end":194,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(tasks))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:194:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(tasks))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6175,"byte_end":6180,"line_start":199,"line_end":199,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:199:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m199\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6189,"byte_end":6194,"line_start":199,"line_end":199,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:199:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m199\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6223,"byte_end":6227,"line_start":200,"line_end":200,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:200:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Task>, (Sta\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Task` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6228,"byte_end":6232,"line_start":200,"line_end":200,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":18,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Task;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Task` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:200:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mult<Json<Task>, (StatusCo\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Task;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6236,"byte_end":6246,"line_start":200,"line_end":200,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6236,"byte_end":6246,"line_start":200,"line_end":200,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":6236,"byte_end":6246,"line_start":200,"line_end":200,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6141,"byte_end":6141,"line_start":197,"line_end":197,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"async fn get_task(","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:200:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mk>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Task>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m200\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Task>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Task>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m200\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Task>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m197\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_task\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Task` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6294,"byte_end":6298,"line_start":201,"line_end":201,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let task = sqlx::query_as::<_, Task>(","highlight_start":36,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Task;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Task` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:201:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m201\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_as::<_, Task>(\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Task;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6583,"byte_end":6587,"line_start":209,"line_end":209,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(task))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:209:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(task))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6624,"byte_end":6629,"line_start":213,"line_end":213,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:213:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m213\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6664,"byte_end":6668,"line_start":214,"line_end":214,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:214:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m214\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6638,"byte_end":6643,"line_start":213,"line_end":213,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:213:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m213\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6679,"byte_end":6683,"line_start":214,"line_end":214,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:214:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m214\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6716,"byte_end":6720,"line_start":215,"line_end":215,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:215:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Task>, (Sta\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Task` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6721,"byte_end":6725,"line_start":215,"line_end":215,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":18,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Task;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Task` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:215:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mult<Json<Task>, (StatusCo\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Task;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6729,"byte_end":6739,"line_start":215,"line_end":215,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6729,"byte_end":6739,"line_start":215,"line_end":215,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":6729,"byte_end":6739,"line_start":215,"line_end":215,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6618,"byte_end":6618,"line_start":212,"line_end":212,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"async fn create_task(","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:215:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mk>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Task>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m215\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Task>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Task>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m215\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Task>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn create_task\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7351,"byte_end":7356,"line_start":228,"line_end":228,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    get_task(Path(id), State(state)).await","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7351,"byte_end":7356,"line_start":228,"line_end":228,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    get_task(Path(id), State(state)).await","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":"state","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:228:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m228\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mPath(id), State(state)).a\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a local variable with a similar name exists (notice the capitalization)\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m228\u001b[0m \u001b[91m- \u001b[0m    get_task(Path(id), \u001b[91mState\u001b[0m(state)).await\n\u001b[1m\u001b[94m228\u001b[0m \u001b[92m+ \u001b[0m    get_task(Path(id), \u001b[92mstate\u001b[0m(state)).await\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7428,"byte_end":7433,"line_start":233,"line_end":233,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:233:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m233\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7468,"byte_end":7472,"line_start":234,"line_end":234,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:234:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m234\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7442,"byte_end":7447,"line_start":233,"line_end":233,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:233:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m233\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7483,"byte_end":7487,"line_start":234,"line_end":234,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:234:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m234\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7520,"byte_end":7524,"line_start":235,"line_end":235,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:235:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Task>, (Sta\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Task` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7525,"byte_end":7529,"line_start":235,"line_end":235,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":18,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Task;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Task` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:235:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mult<Json<Task>, (StatusCo\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Task;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7533,"byte_end":7543,"line_start":235,"line_end":235,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7533,"byte_end":7543,"line_start":235,"line_end":235,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":7533,"byte_end":7543,"line_start":235,"line_end":235,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<Json<Task>, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7394,"byte_end":7394,"line_start":231,"line_end":231,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"async fn update_task(","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:235:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mk>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Task>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m235\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Task>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Task>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m235\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Task>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m231\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn update_task\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8058,"byte_end":8063,"line_start":247,"line_end":247,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    get_task(Path(id), State(state)).await","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8058,"byte_end":8063,"line_start":247,"line_end":247,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    get_task(Path(id), State(state)).await","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":"state","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:247:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m247\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mPath(id), State(state)).a\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a local variable with a similar name exists (notice the capitalization)\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m247\u001b[0m \u001b[91m- \u001b[0m    get_task(Path(id), \u001b[91mState\u001b[0m(state)).await\n\u001b[1m\u001b[94m247\u001b[0m \u001b[92m+ \u001b[0m    get_task(Path(id), \u001b[92mstate\u001b[0m(state)).await\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8135,"byte_end":8140,"line_start":252,"line_end":252,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:252:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m252\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8149,"byte_end":8154,"line_start":252,"line_end":252,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:252:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m252\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8183,"byte_end":8193,"line_start":253,"line_end":253,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":13,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8183,"byte_end":8193,"line_start":253,"line_end":253,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":8183,"byte_end":8193,"line_start":253,"line_end":253,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8101,"byte_end":8101,"line_start":250,"line_end":250,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"async fn delete_task(","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:253:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0msult<StatusCode, (StatusC\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[91m- \u001b[0m) -> Result<\u001b[91mStatusCode\u001b[0m, (StatusCode, String)> {\n\u001b[1m\u001b[94m253\u001b[0m \u001b[92m+ \u001b[0m) -> Result<\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[91m- \u001b[0m) -> Result<\u001b[91mStatusCode\u001b[0m, (StatusCode, String)> {\n\u001b[1m\u001b[94m253\u001b[0m \u001b[92m+ \u001b[0m) -> Result<\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m250\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn delete_task\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8196,"byte_end":8206,"line_start":253,"line_end":253,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8196,"byte_end":8206,"line_start":253,"line_end":253,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":8196,"byte_end":8206,"line_start":253,"line_end":253,"column_start":26,"column_end":36,"is_primary":true,"text":[{"text":") -> Result<StatusCode, (StatusCode, String)> {","highlight_start":26,"highlight_end":36}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8101,"byte_end":8101,"line_start":250,"line_end":250,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"async fn delete_task(","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:253:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mde, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[91m- \u001b[0m) -> Result<StatusCode, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m253\u001b[0m \u001b[92m+ \u001b[0m) -> Result<StatusCode, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[91m- \u001b[0m) -> Result<StatusCode, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m253\u001b[0m \u001b[92m+ \u001b[0m) -> Result<StatusCode, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m250\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn delete_task\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8502,"byte_end":8507,"line_start":265,"line_end":265,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:265:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m265\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8516,"byte_end":8521,"line_start":265,"line_end":265,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:265:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m265\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8550,"byte_end":8554,"line_start":266,"line_end":266,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Comment>>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:266:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m266\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Vec<Comment\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Comment` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8559,"byte_end":8566,"line_start":266,"line_end":266,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Comment>>, (StatusCode, String)> {","highlight_start":22,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Comment;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Comment` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:266:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m266\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mon<Vec<Comment>>, (Status\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Comment;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8571,"byte_end":8581,"line_start":266,"line_end":266,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Comment>>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8571,"byte_end":8581,"line_start":266,"line_end":266,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Comment>>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":8571,"byte_end":8581,"line_start":266,"line_end":266,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Comment>>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8463,"byte_end":8463,"line_start":263,"line_end":263,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn get_comments(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:266:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m266\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m>>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m266\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Comment>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m266\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Comment>>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m266\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Comment>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m266\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Comment>>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m263\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_comments\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Comment` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8633,"byte_end":8640,"line_start":267,"line_end":267,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    let comments = sqlx::query_as::<_, Comment>(","highlight_start":40,"highlight_end":47}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Comment;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Comment` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:267:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0ms::<_, Comment>(\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Comment;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8878,"byte_end":8882,"line_start":275,"line_end":275,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(comments))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:275:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m275\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(comments))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8959,"byte_end":8964,"line_start":280,"line_end":280,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:280:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8999,"byte_end":9003,"line_start":281,"line_end":281,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:281:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m281\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8973,"byte_end":8978,"line_start":280,"line_end":280,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:280:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9014,"byte_end":9018,"line_start":281,"line_end":281,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:281:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m281\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9051,"byte_end":9055,"line_start":282,"line_end":282,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Comment>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:282:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m282\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Comment>, (\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Comment` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9056,"byte_end":9063,"line_start":282,"line_end":282,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":") -> Result<Json<Comment>, (StatusCode, String)> {","highlight_start":18,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Comment;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Comment` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:282:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m282\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt<Json<Comment>, (StatusC\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Comment;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9067,"byte_end":9077,"line_start":282,"line_end":282,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":") -> Result<Json<Comment>, (StatusCode, String)> {","highlight_start":29,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9067,"byte_end":9077,"line_start":282,"line_end":282,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":") -> Result<Json<Comment>, (StatusCode, String)> {","highlight_start":29,"highlight_end":39}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":9067,"byte_end":9077,"line_start":282,"line_end":282,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":") -> Result<Json<Comment>, (StatusCode, String)> {","highlight_start":29,"highlight_end":39}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8920,"byte_end":8920,"line_start":278,"line_end":278,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"async fn create_comment(","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:282:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m282\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m282\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Comment>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m282\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Comment>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m282\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Comment>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m282\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Comment>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m278\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn create_comment\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Comment` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9740,"byte_end":9747,"line_start":296,"line_end":296,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"    let comment = sqlx::query_as::<_, Comment>(","highlight_start":39,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Comment;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Comment` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:296:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m296\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0ms::<_, Comment>(\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Comment;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10076,"byte_end":10080,"line_start":306,"line_end":306,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(comment))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:306:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m306\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(comment))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10126,"byte_end":10131,"line_start":310,"line_end":310,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:310:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m310\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10140,"byte_end":10145,"line_start":310,"line_end":310,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:310:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m310\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10174,"byte_end":10178,"line_start":311,"line_end":311,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Announcement>>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:311:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Vec<Announc\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Announcement` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10183,"byte_end":10195,"line_start":311,"line_end":311,"column_start":22,"column_end":34,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Announcement>>, (StatusCode, String)> {","highlight_start":22,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Announcement;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Announcement` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:311:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m<Vec<Announcement>>, (Sta\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Announcement;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10200,"byte_end":10210,"line_start":311,"line_end":311,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Announcement>>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10200,"byte_end":10210,"line_start":311,"line_end":311,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Announcement>>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":10200,"byte_end":10210,"line_start":311,"line_end":311,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<Announcement>>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10120,"byte_end":10120,"line_start":309,"line_end":309,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn get_announcements(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:311:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m>>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Announcement>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m311\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Announcement>>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<Announcement>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m311\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<Announcement>>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m309\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_announcements\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Announcement` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10267,"byte_end":10279,"line_start":312,"line_end":312,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"    let announcements = sqlx::query_as::<_, Announcement>(","highlight_start":45,"highlight_end":57}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Announcement;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Announcement` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:312:45\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m312\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m:<_, Announcement>(\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Announcement;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10520,"byte_end":10524,"line_start":319,"line_end":319,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(announcements))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:319:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m319\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(announcements))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10578,"byte_end":10583,"line_start":323,"line_end":323,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:323:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m323\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10618,"byte_end":10622,"line_start":324,"line_end":324,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:324:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m324\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10592,"byte_end":10597,"line_start":323,"line_end":323,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:323:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m323\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10633,"byte_end":10637,"line_start":324,"line_end":324,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:324:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m324\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10670,"byte_end":10674,"line_start":325,"line_end":325,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Announcement>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:325:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Announcemen\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Announcement` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10675,"byte_end":10687,"line_start":325,"line_end":325,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":") -> Result<Json<Announcement>, (StatusCode, String)> {","highlight_start":18,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Announcement;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Announcement` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:325:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mJson<Announcement>, (Stat\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Announcement;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10691,"byte_end":10701,"line_start":325,"line_end":325,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<Announcement>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10691,"byte_end":10701,"line_start":325,"line_end":325,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<Announcement>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":10691,"byte_end":10701,"line_start":325,"line_end":325,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<Announcement>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10572,"byte_end":10572,"line_start":322,"line_end":322,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"async fn create_announcement(","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:325:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mt>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Announcement>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m325\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Announcement>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Announcement>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m325\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Announcement>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m322\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn create_announcement\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Announcement` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11386,"byte_end":11398,"line_start":340,"line_end":340,"column_start":44,"column_end":56,"is_primary":true,"text":[{"text":"    let announcement = sqlx::query_as::<_, Announcement>(","highlight_start":44,"highlight_end":56}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::models::Announcement;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Announcement` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:340:44\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m340\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m:<_, Announcement>(\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use crate::models::Announcement;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11711,"byte_end":11715,"line_start":350,"line_end":350,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(announcement))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:350:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m350\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(announcement))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11761,"byte_end":11766,"line_start":354,"line_end":354,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:354:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m354\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11775,"byte_end":11780,"line_start":354,"line_end":354,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:354:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m354\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11809,"byte_end":11813,"line_start":355,"line_end":355,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<ActivityLog>>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:355:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m355\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Vec<Activit\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ActivityLog` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11818,"byte_end":11829,"line_start":355,"line_end":355,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<ActivityLog>>, (StatusCode, String)> {","highlight_start":22,"highlight_end":33}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11755,"byte_end":11755,"line_start":353,"line_end":353,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn get_activity(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<ActivityLog>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `ActivityLog` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:355:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m355\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m<Vec<ActivityLog>>, (Stat\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m353\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_activity\u001b[92m<ActivityLog>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m+++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11834,"byte_end":11844,"line_start":355,"line_end":355,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<ActivityLog>>, (StatusCode, String)> {","highlight_start":38,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11834,"byte_end":11844,"line_start":355,"line_end":355,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<ActivityLog>>, (StatusCode, String)> {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":11834,"byte_end":11844,"line_start":355,"line_end":355,"column_start":38,"column_end":48,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<ActivityLog>>, (StatusCode, String)> {","highlight_start":38,"highlight_end":48}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11755,"byte_end":11755,"line_start":353,"line_end":353,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn get_activity(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:355:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m355\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m>>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m355\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<ActivityLog>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m355\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<ActivityLog>>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m355\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<ActivityLog>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m355\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<ActivityLog>>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m353\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_activity\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ActivityLog` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11896,"byte_end":11907,"line_start":356,"line_end":356,"column_start":40,"column_end":51,"is_primary":true,"text":[{"text":"    let activity = sqlx::query_as::<_, ActivityLog>(","highlight_start":40,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11755,"byte_end":11755,"line_start":353,"line_end":353,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"async fn get_activity(","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<ActivityLog>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `ActivityLog` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:356:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m356\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m:<_, ActivityLog>(\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m353\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_activity\u001b[92m<ActivityLog>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m+++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12165,"byte_end":12169,"line_start":363,"line_end":363,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(activity))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:363:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m363\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(activity))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12249,"byte_end":12254,"line_start":368,"line_end":368,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:368:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m368\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12263,"byte_end":12268,"line_start":368,"line_end":368,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:368:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m368\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12297,"byte_end":12301,"line_start":369,"line_end":369,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<TaskActivity>>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:369:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m369\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<Vec<TaskAct\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `TaskActivity` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12306,"byte_end":12318,"line_start":369,"line_end":369,"column_start":22,"column_end":34,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<TaskActivity>>, (StatusCode, String)> {","highlight_start":22,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12210,"byte_end":12210,"line_start":366,"line_end":366,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn get_task_activity(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<TaskActivity>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `TaskActivity` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:369:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m369\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m<Vec<TaskActivity>>, (Sta\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m366\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_task_activity\u001b[92m<TaskActivity>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12323,"byte_end":12333,"line_start":369,"line_end":369,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<TaskActivity>>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12323,"byte_end":12333,"line_start":369,"line_end":369,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<TaskActivity>>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":12323,"byte_end":12333,"line_start":369,"line_end":369,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<Vec<TaskActivity>>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12210,"byte_end":12210,"line_start":366,"line_end":366,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn get_task_activity(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:369:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m369\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m>>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m369\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<TaskActivity>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m369\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<TaskActivity>>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m369\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<Vec<TaskActivity>>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m369\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<Vec<TaskActivity>>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m366\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_task_activity\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `TaskActivity` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12385,"byte_end":12397,"line_start":370,"line_end":370,"column_start":40,"column_end":52,"is_primary":true,"text":[{"text":"    let activity = sqlx::query_as::<_, TaskActivity>(","highlight_start":40,"highlight_end":52}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12210,"byte_end":12210,"line_start":366,"line_end":366,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn get_task_activity(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<TaskActivity>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `TaskActivity` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:370:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m:<_, TaskActivity>(\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m366\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_task_activity\u001b[92m<TaskActivity>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12663,"byte_end":12667,"line_start":378,"line_end":378,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(activity))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:378:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m378\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(activity))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12747,"byte_end":12752,"line_start":383,"line_end":383,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:383:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m383\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Json` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12787,"byte_end":12791,"line_start":384,"line_end":384,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":5,"highlight_end":9}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:384:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m384\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(payload): Json<serd\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12761,"byte_end":12766,"line_start":383,"line_end":383,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:383:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m383\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12802,"byte_end":12806,"line_start":384,"line_end":384,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    Json(payload): Json<serde_json::Value>,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:384:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m384\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mayload): Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12839,"byte_end":12843,"line_start":385,"line_end":385,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<TaskActivity>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:385:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m385\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<TaskActivit\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `TaskActivity` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12844,"byte_end":12856,"line_start":385,"line_end":385,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":") -> Result<Json<TaskActivity>, (StatusCode, String)> {","highlight_start":18,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12708,"byte_end":12708,"line_start":381,"line_end":381,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn add_task_activity(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<TaskActivity>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `TaskActivity` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:385:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m385\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mJson<TaskActivity>, (Stat\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m381\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn add_task_activity\u001b[92m<TaskActivity>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12860,"byte_end":12870,"line_start":385,"line_end":385,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<TaskActivity>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12860,"byte_end":12870,"line_start":385,"line_end":385,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<TaskActivity>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":12860,"byte_end":12870,"line_start":385,"line_end":385,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":") -> Result<Json<TaskActivity>, (StatusCode, String)> {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12708,"byte_end":12708,"line_start":381,"line_end":381,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn add_task_activity(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:385:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m385\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0my>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m385\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<TaskActivity>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m385\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<TaskActivity>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m385\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<TaskActivity>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m385\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<TaskActivity>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m381\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn add_task_activity\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `TaskActivity` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13471,"byte_end":13483,"line_start":399,"line_end":399,"column_start":40,"column_end":52,"is_primary":true,"text":[{"text":"    let activity = sqlx::query_as::<_, TaskActivity>(","highlight_start":40,"highlight_end":52}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12708,"byte_end":12708,"line_start":381,"line_end":381,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"async fn add_task_activity(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<TaskActivity>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `TaskActivity` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:399:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m399\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m:<_, TaskActivity>(\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m381\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn add_task_activity\u001b[92m<TaskActivity>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13822,"byte_end":13826,"line_start":409,"line_end":409,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(activity))","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:409:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m409\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(activity))\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `State` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13865,"byte_end":13870,"line_start":413,"line_end":413,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":5,"highlight_end":10}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:413:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m413\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     State(state): State<Arc<\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `State` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13879,"byte_end":13884,"line_start":413,"line_end":413,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    State(state): State<Arc<AppState>>,","highlight_start":19,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::extract::State;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `State` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:413:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m413\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mtate): State<Arc<AppState>>,\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::extract::State;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13913,"byte_end":13917,"line_start":414,"line_end":414,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":") -> Result<Json<serde_json::Value>, (StatusCode, String)> {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:414:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m414\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<Json<serde_json:\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `StatusCode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13939,"byte_end":13949,"line_start":414,"line_end":414,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<serde_json::Value>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13939,"byte_end":13949,"line_start":414,"line_end":414,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<serde_json::Value>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":13939,"byte_end":13949,"line_start":414,"line_end":414,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":") -> Result<Json<serde_json::Value>, (StatusCode, String)> {","highlight_start":39,"highlight_end":49}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13859,"byte_end":13859,"line_start":412,"line_end":412,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"async fn get_stats(","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"<StatusCode>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `StatusCode` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:414:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m414\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0me>, (StatusCode, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m414\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<serde_json::Value>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m414\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<serde_json::Value>, (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m414\u001b[0m \u001b[91m- \u001b[0m) -> Result<Json<serde_json::Value>, (\u001b[91mStatusCode\u001b[0m, String)> {\n\u001b[1m\u001b[94m414\u001b[0m \u001b[92m+ \u001b[0m) -> Result<Json<serde_json::Value>, (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m, String)> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m412\u001b[0m \u001b[1m\u001b[94m| \u001b[0masync fn get_stats\u001b[92m<StatusCode>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Json` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14587,"byte_end":14591,"line_start":430,"line_end":430,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(Json(serde_json::json!({","highlight_start":8,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these tuple structs","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":21,"byte_end":21,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::Json;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `Json` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:430:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m430\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Json(serde_json::json!({\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple structs\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use axum::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ use sqlx::types::Json;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Mutex`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":42,"byte_end":47,"line_start":4,"line_end":4,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":22,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":40,"byte_end":47,"line_start":4,"line_end":4,"column_start":20,"column_end":27,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":20,"highlight_end":27}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":36,"byte_end":37,"line_start":4,"line_end":4,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":16,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":47,"byte_end":48,"line_start":4,"line_end":4,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"use std::sync::{Arc, Mutex};","highlight_start":27,"highlight_end":28}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Mutex`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:4:22\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::sync::{Arc, Mutex};\n  \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3298,"byte_end":3540,"line_start":111,"line_end":115,"column_start":18,"column_end":11,"is_primary":true,"text":[{"text":"    let agents = sqlx::query_as::<_, Agent>(","highlight_start":18,"highlight_end":45},{"text":"        \"SELECT id, name, role, description, avatar, status, workspace, token, primary_model, fallback_model, current_model, model_failure_count, created_at FROM agents\"","highlight_start":1,"highlight_end":170},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_all(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:111:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let agents = sqlx::que\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m __________________^\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, name, \u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.pool)\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3559,"byte_end":3569,"line_start":116,"line_end":116,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3559,"byte_end":3569,"line_start":116,"line_end":116,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":3559,"byte_end":3569,"line_start":116,"line_end":116,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:116:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m116\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m116\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3594,"byte_end":3595,"line_start":116,"line_end":116,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3555,"byte_end":3556,"line_start":116,"line_end":116,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3556,"byte_end":3556,"line_start":116,"line_end":116,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:116:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3790,"byte_end":4059,"line_start":125,"line_end":130,"column_start":17,"column_end":11,"is_primary":true,"text":[{"text":"    let agent = sqlx::query_as::<_, Agent>(","highlight_start":17,"highlight_end":44},{"text":"        \"SELECT id, name, role, description, avatar, status, workspace, token, primary_model, fallback_model, current_model, model_failure_count, created_at FROM agents WHERE id = ?\"","highlight_start":1,"highlight_end":183},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .fetch_one(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:125:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let agent = sqlx::quer\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m126\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, name, \u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(id)\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_one(&state.pool)\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4078,"byte_end":4088,"line_start":131,"line_end":131,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4078,"byte_end":4088,"line_start":131,"line_end":131,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":4078,"byte_end":4088,"line_start":131,"line_end":131,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:131:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::NOT_FOUN\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::NOT_FOUND, e.to_string()))?;\n\u001b[1m\u001b[94m131\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::NOT_FOUND, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::NOT_FOUND, e.to_string()))?;\n\u001b[1m\u001b[94m131\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::NOT_FOUND, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4101,"byte_end":4102,"line_start":131,"line_end":131,"column_start":42,"column_end":43,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":42,"highlight_end":43}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4074,"byte_end":4075,"line_start":131,"line_end":131,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4075,"byte_end":4075,"line_start":131,"line_end":131,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:131:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::NOT_FOUND, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                          \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::NOT_FOUND, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4453,"byte_end":4655,"line_start":144,"line_end":148,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"INSERT INTO agents (id, name, role, status, created_at) VALUES (?, ?, 'SPC', 'IDLE', CURRENT_TIMESTAMP)\")","highlight_start":5,"highlight_end":123},{"text":"        .bind(&id)","highlight_start":1,"highlight_end":19},{"text":"        .bind(name)","highlight_start":1,"highlight_end":20},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:144:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"INSERT IN\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&id)\n\u001b[1m\u001b[94m146\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(name)\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4678,"byte_end":4688,"line_start":149,"line_end":149,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4678,"byte_end":4688,"line_start":149,"line_end":149,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":4678,"byte_end":4688,"line_start":149,"line_end":149,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:149:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m149\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m149\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4713,"byte_end":4714,"line_start":149,"line_end":149,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4674,"byte_end":4675,"line_start":149,"line_end":149,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4675,"byte_end":4675,"line_start":149,"line_end":149,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:149:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5026,"byte_end":5184,"line_start":160,"line_end":164,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"        sqlx::query(\"UPDATE agents SET status = ? WHERE id = ?\")","highlight_start":9,"highlight_end":65},{"text":"            .bind(status)","highlight_start":1,"highlight_end":26},{"text":"            .bind(&id)","highlight_start":1,"highlight_end":23},{"text":"            .execute(&state.pool)","highlight_start":1,"highlight_end":34},{"text":"            .await","highlight_start":1,"highlight_end":19}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:160:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m         sqlx::query(\"UPDAT\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m161\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .bind(status)\n\u001b[1m\u001b[94m162\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .bind(&id)\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .execute(&stat\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5211,"byte_end":5221,"line_start":165,"line_end":165,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":27,"highlight_end":37}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5211,"byte_end":5221,"line_start":165,"line_end":165,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":5211,"byte_end":5221,"line_start":165,"line_end":165,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:165:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[91m- \u001b[0m            .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m165\u001b[0m \u001b[92m+ \u001b[0m            .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[91m- \u001b[0m            .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m165\u001b[0m \u001b[92m+ \u001b[0m            .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5246,"byte_end":5247,"line_start":165,"line_end":165,"column_start":62,"column_end":63,"is_primary":false,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":62,"highlight_end":63}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":5207,"byte_end":5208,"line_start":165,"line_end":165,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5208,"byte_end":5208,"line_start":165,"line_end":165,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:165:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5465,"byte_end":5574,"line_start":175,"line_end":178,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"DELETE FROM agents WHERE id = ?\")","highlight_start":5,"highlight_end":51},{"text":"        .bind(id)","highlight_start":1,"highlight_end":18},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:175:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m175\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"DELETE FR\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m176\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(id)\n\u001b[1m\u001b[94m177\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m178\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5597,"byte_end":5607,"line_start":179,"line_end":179,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5597,"byte_end":5607,"line_start":179,"line_end":179,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":5597,"byte_end":5607,"line_start":179,"line_end":179,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:179:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m179\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m179\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m179\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m179\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m179\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5632,"byte_end":5633,"line_start":179,"line_end":179,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":5593,"byte_end":5594,"line_start":179,"line_end":179,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5594,"byte_end":5594,"line_start":179,"line_end":179,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:179:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m179\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m179\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5658,"byte_end":5668,"line_start":181,"line_end":181,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(StatusCode::NO_CONTENT)","highlight_start":8,"highlight_end":18}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5658,"byte_end":5668,"line_start":181,"line_end":181,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(StatusCode::NO_CONTENT)","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":5658,"byte_end":5668,"line_start":181,"line_end":181,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(StatusCode::NO_CONTENT)","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:181:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(StatusCode::NO_CONTENT)\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[91m- \u001b[0m    Ok(\u001b[91mStatusCode\u001b[0m::NO_CONTENT)\n\u001b[1m\u001b[94m181\u001b[0m \u001b[92m+ \u001b[0m    Ok(\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::NO_CONTENT)\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[91m- \u001b[0m    Ok(\u001b[91mStatusCode\u001b[0m::NO_CONTENT)\n\u001b[1m\u001b[94m181\u001b[0m \u001b[92m+ \u001b[0m    Ok(\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::NO_CONTENT)\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5814,"byte_end":6028,"line_start":187,"line_end":191,"column_start":17,"column_end":11,"is_primary":true,"text":[{"text":"    let tasks = sqlx::query_as::<_, Task>(","highlight_start":17,"highlight_end":43},{"text":"        \"SELECT id, title, description, status, priority, tags, assignee_id, reviewer, reviewer_id, created_at, updated_at, due_at FROM tasks\"","highlight_start":1,"highlight_end":143},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_all(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:187:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m187\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let tasks = sqlx::quer\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m188\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, title,\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.pool)\n\u001b[1m\u001b[94m191\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6047,"byte_end":6057,"line_start":192,"line_end":192,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6047,"byte_end":6057,"line_start":192,"line_end":192,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":6047,"byte_end":6057,"line_start":192,"line_end":192,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:192:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m192\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m192\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6082,"byte_end":6083,"line_start":192,"line_end":192,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":6043,"byte_end":6044,"line_start":192,"line_end":192,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6044,"byte_end":6044,"line_start":192,"line_end":192,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:192:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6274,"byte_end":6515,"line_start":201,"line_end":206,"column_start":16,"column_end":11,"is_primary":true,"text":[{"text":"    let task = sqlx::query_as::<_, Task>(","highlight_start":16,"highlight_end":42},{"text":"        \"SELECT id, title, description, status, priority, tags, assignee_id, reviewer, reviewer_id, created_at, updated_at, due_at FROM tasks WHERE id = ?\"","highlight_start":1,"highlight_end":156},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .fetch_one(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:201:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m201\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let task = sqlx::query\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m202\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, title,\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m203\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m204\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(id)\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_one(&state.pool)\n\u001b[1m\u001b[94m206\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6534,"byte_end":6544,"line_start":207,"line_end":207,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6534,"byte_end":6544,"line_start":207,"line_end":207,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":6534,"byte_end":6544,"line_start":207,"line_end":207,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:207:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::NOT_FOUN\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::NOT_FOUND, e.to_string()))?;\n\u001b[1m\u001b[94m207\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::NOT_FOUND, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::NOT_FOUND, e.to_string()))?;\n\u001b[1m\u001b[94m207\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::NOT_FOUND, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6557,"byte_end":6558,"line_start":207,"line_end":207,"column_start":42,"column_end":43,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":42,"highlight_end":43}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":6530,"byte_end":6531,"line_start":207,"line_end":207,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6531,"byte_end":6531,"line_start":207,"line_end":207,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::NOT_FOUND, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:207:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::NOT_FOUND, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                          \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::NOT_FOUND, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6848,"byte_end":6858,"line_start":217,"line_end":217,"column_start":50,"column_end":60,"is_primary":true,"text":[{"text":"    let title = payload[\"title\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"Title required\".to_string()))?;","highlight_start":50,"highlight_end":60}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6848,"byte_end":6858,"line_start":217,"line_end":217,"column_start":50,"column_end":60,"is_primary":true,"text":[{"text":"    let title = payload[\"title\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"Title required\".to_string()))?;","highlight_start":50,"highlight_end":60}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":6848,"byte_end":6858,"line_start":217,"line_end":217,"column_start":50,"column_end":60,"is_primary":true,"text":[{"text":"    let title = payload[\"title\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"Title required\".to_string()))?;","highlight_start":50,"highlight_end":60}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:217:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m217\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_or((StatusCode::BAD_REQU\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m217\u001b[0m \u001b[91m- \u001b[0m    let title = payload[\"title\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"Title required\".to_string()))?;\n\u001b[1m\u001b[94m217\u001b[0m \u001b[92m+ \u001b[0m    let title = payload[\"title\"].as_str().ok_or((\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::BAD_REQUEST, \"Title required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m217\u001b[0m \u001b[91m- \u001b[0m    let title = payload[\"title\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"Title required\".to_string()))?;\n\u001b[1m\u001b[94m217\u001b[0m \u001b[92m+ \u001b[0m    let title = payload[\"title\"].as_str().ok_or((\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::BAD_REQUEST, \"Title required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6915,"byte_end":7157,"line_start":219,"line_end":223,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"INSERT INTO tasks (id, title, status, priority, created_at, updated_at) VALUES (?, ?, 'INBOX', 'NORMAL', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\")","highlight_start":5,"highlight_end":162},{"text":"        .bind(&id)","highlight_start":1,"highlight_end":19},{"text":"        .bind(title)","highlight_start":1,"highlight_end":21},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:219:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m219\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"INSERT IN\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m220\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&id)\n\u001b[1m\u001b[94m221\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(title)\n\u001b[1m\u001b[94m222\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7180,"byte_end":7190,"line_start":224,"line_end":224,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7180,"byte_end":7190,"line_start":224,"line_end":224,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":7180,"byte_end":7190,"line_start":224,"line_end":224,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:224:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m224\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m224\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7215,"byte_end":7216,"line_start":224,"line_end":224,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":7176,"byte_end":7177,"line_start":224,"line_end":224,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7177,"byte_end":7177,"line_start":224,"line_end":224,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:224:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7619,"byte_end":7808,"line_start":237,"line_end":241,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"        sqlx::query(\"UPDATE tasks SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?\")","highlight_start":9,"highlight_end":96},{"text":"            .bind(status)","highlight_start":1,"highlight_end":26},{"text":"            .bind(&id)","highlight_start":1,"highlight_end":23},{"text":"            .execute(&state.pool)","highlight_start":1,"highlight_end":34},{"text":"            .await","highlight_start":1,"highlight_end":19}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:237:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m237\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m         sqlx::query(\"UPDAT\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m238\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .bind(status)\n\u001b[1m\u001b[94m239\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .bind(&id)\n\u001b[1m\u001b[94m240\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .execute(&stat\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m241\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7835,"byte_end":7845,"line_start":242,"line_end":242,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":27,"highlight_end":37}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7835,"byte_end":7845,"line_start":242,"line_end":242,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":7835,"byte_end":7845,"line_start":242,"line_end":242,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":27,"highlight_end":37}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:242:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m242\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m242\u001b[0m \u001b[91m- \u001b[0m            .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m242\u001b[0m \u001b[92m+ \u001b[0m            .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m242\u001b[0m \u001b[91m- \u001b[0m            .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m242\u001b[0m \u001b[92m+ \u001b[0m            .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7870,"byte_end":7871,"line_start":242,"line_end":242,"column_start":62,"column_end":63,"is_primary":false,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":62,"highlight_end":63}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":7831,"byte_end":7832,"line_start":242,"line_end":242,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":7832,"byte_end":7832,"line_start":242,"line_end":242,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:242:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m242\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m242\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8223,"byte_end":8331,"line_start":254,"line_end":257,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"DELETE FROM tasks WHERE id = ?\")","highlight_start":5,"highlight_end":50},{"text":"        .bind(id)","highlight_start":1,"highlight_end":18},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:254:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m254\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"DELETE FR\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m255\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(id)\n\u001b[1m\u001b[94m256\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m257\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8354,"byte_end":8364,"line_start":258,"line_end":258,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8354,"byte_end":8364,"line_start":258,"line_end":258,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":8354,"byte_end":8364,"line_start":258,"line_end":258,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:258:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m258\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m258\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8389,"byte_end":8390,"line_start":258,"line_end":258,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8350,"byte_end":8351,"line_start":258,"line_end":258,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8351,"byte_end":8351,"line_start":258,"line_end":258,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:258:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8415,"byte_end":8425,"line_start":260,"line_end":260,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(StatusCode::NO_CONTENT)","highlight_start":8,"highlight_end":18}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8415,"byte_end":8425,"line_start":260,"line_end":260,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(StatusCode::NO_CONTENT)","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":8415,"byte_end":8425,"line_start":260,"line_end":260,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(StatusCode::NO_CONTENT)","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:260:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m260\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(StatusCode::NO_CONTENT)\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m260\u001b[0m \u001b[91m- \u001b[0m    Ok(\u001b[91mStatusCode\u001b[0m::NO_CONTENT)\n\u001b[1m\u001b[94m260\u001b[0m \u001b[92m+ \u001b[0m    Ok(\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::NO_CONTENT)\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m260\u001b[0m \u001b[91m- \u001b[0m    Ok(\u001b[91mStatusCode\u001b[0m::NO_CONTENT)\n\u001b[1m\u001b[94m260\u001b[0m \u001b[92m+ \u001b[0m    Ok(\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::NO_CONTENT)\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8613,"byte_end":8798,"line_start":267,"line_end":272,"column_start":20,"column_end":11,"is_primary":true,"text":[{"text":"    let comments = sqlx::query_as::<_, Comment>(","highlight_start":20,"highlight_end":49},{"text":"        \"SELECT id, task_id, agent_id, content, created_at FROM comments WHERE task_id = ?\"","highlight_start":1,"highlight_end":92},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(task_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_all(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:267:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let comments = sqlx::q\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m268\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, task_i\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m270\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(task_id)\n\u001b[1m\u001b[94m271\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.pool)\n\u001b[1m\u001b[94m272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8817,"byte_end":8827,"line_start":273,"line_end":273,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8817,"byte_end":8827,"line_start":273,"line_end":273,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":8817,"byte_end":8827,"line_start":273,"line_end":273,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:273:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m273\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m273\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8852,"byte_end":8853,"line_start":273,"line_end":273,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8813,"byte_end":8814,"line_start":273,"line_end":273,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8814,"byte_end":8814,"line_start":273,"line_end":273,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:273:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9192,"byte_end":9202,"line_start":284,"line_end":284,"column_start":56,"column_end":66,"is_primary":true,"text":[{"text":"    let agent_id = payload[\"agent_id\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"agent_id required\".to_string()))?;","highlight_start":56,"highlight_end":66}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9192,"byte_end":9202,"line_start":284,"line_end":284,"column_start":56,"column_end":66,"is_primary":true,"text":[{"text":"    let agent_id = payload[\"agent_id\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"agent_id required\".to_string()))?;","highlight_start":56,"highlight_end":66}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":9192,"byte_end":9202,"line_start":284,"line_end":284,"column_start":56,"column_end":66,"is_primary":true,"text":[{"text":"    let agent_id = payload[\"agent_id\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"agent_id required\".to_string()))?;","highlight_start":56,"highlight_end":66}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:284:56\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m284\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_or((StatusCode::BAD_REQU\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m284\u001b[0m \u001b[91m- \u001b[0m    let agent_id = payload[\"agent_id\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"agent_id required\".to_string()))?;\n\u001b[1m\u001b[94m284\u001b[0m \u001b[92m+ \u001b[0m    let agent_id = payload[\"agent_id\"].as_str().ok_or((\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::BAD_REQUEST, \"agent_id required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m284\u001b[0m \u001b[91m- \u001b[0m    let agent_id = payload[\"agent_id\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"agent_id required\".to_string()))?;\n\u001b[1m\u001b[94m284\u001b[0m \u001b[92m+ \u001b[0m    let agent_id = payload[\"agent_id\"].as_str().ok_or((\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::BAD_REQUEST, \"agent_id required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9306,"byte_end":9316,"line_start":285,"line_end":285,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let content = payload[\"content\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"content required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9306,"byte_end":9316,"line_start":285,"line_end":285,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let content = payload[\"content\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"content required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":9306,"byte_end":9316,"line_start":285,"line_end":285,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let content = payload[\"content\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"content required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:285:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m285\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_or((StatusCode::BAD_REQU\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m285\u001b[0m \u001b[91m- \u001b[0m    let content = payload[\"content\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"content required\".to_string()))?;\n\u001b[1m\u001b[94m285\u001b[0m \u001b[92m+ \u001b[0m    let content = payload[\"content\"].as_str().ok_or((\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::BAD_REQUEST, \"content required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m285\u001b[0m \u001b[91m- \u001b[0m    let content = payload[\"content\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"content required\".to_string()))?;\n\u001b[1m\u001b[94m285\u001b[0m \u001b[92m+ \u001b[0m    let content = payload[\"content\"].as_str().ok_or((\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::BAD_REQUEST, \"content required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9371,"byte_end":9625,"line_start":287,"line_end":293,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"INSERT INTO comments (id, task_id, agent_id, content, created_at) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\")","highlight_start":5,"highlight_end":124},{"text":"        .bind(&id)","highlight_start":1,"highlight_end":19},{"text":"        .bind(&task_id)","highlight_start":1,"highlight_end":24},{"text":"        .bind(agent_id)","highlight_start":1,"highlight_end":24},{"text":"        .bind(content)","highlight_start":1,"highlight_end":23},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:287:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m287\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"INSERT IN\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&id)\n\u001b[1m\u001b[94m289\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&task_id)\n\u001b[1m\u001b[94m290\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(agent_id)\n\u001b[1m\u001b[94m291\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(content)\n\u001b[1m\u001b[94m292\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m293\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9648,"byte_end":9658,"line_start":294,"line_end":294,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9648,"byte_end":9658,"line_start":294,"line_end":294,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":9648,"byte_end":9658,"line_start":294,"line_end":294,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:294:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m294\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m294\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m294\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m294\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m294\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9683,"byte_end":9684,"line_start":294,"line_end":294,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9644,"byte_end":9645,"line_start":294,"line_end":294,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9645,"byte_end":9645,"line_start":294,"line_end":294,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:294:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m294\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m294\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9720,"byte_end":9896,"line_start":296,"line_end":301,"column_start":19,"column_end":11,"is_primary":true,"text":[{"text":"    let comment = sqlx::query_as::<_, Comment>(","highlight_start":19,"highlight_end":48},{"text":"        \"SELECT id, task_id, agent_id, content, created_at FROM comments WHERE id = ?\"","highlight_start":1,"highlight_end":87},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&id)","highlight_start":1,"highlight_end":15},{"text":"    .fetch_one(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:296:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m296\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let comment = sqlx::qu\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ___________________^\u001b[0m\n\u001b[1m\u001b[94m297\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, task_i\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m298\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m299\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(&id)\n\u001b[1m\u001b[94m300\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_one(&state.pool)\n\u001b[1m\u001b[94m301\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9915,"byte_end":9925,"line_start":302,"line_end":302,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9915,"byte_end":9925,"line_start":302,"line_end":302,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":9915,"byte_end":9925,"line_start":302,"line_end":302,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:302:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m302\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m302\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m302\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m302\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m302\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9950,"byte_end":9951,"line_start":302,"line_end":302,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9911,"byte_end":9912,"line_start":302,"line_end":302,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":9912,"byte_end":9912,"line_start":302,"line_end":302,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:302:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m302\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m302\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10247,"byte_end":10440,"line_start":312,"line_end":316,"column_start":25,"column_end":11,"is_primary":true,"text":[{"text":"    let announcements = sqlx::query_as::<_, Announcement>(","highlight_start":25,"highlight_end":59},{"text":"        \"SELECT id, title, message, priority, created_at, created_by FROM announcements ORDER BY created_at DESC\"","highlight_start":1,"highlight_end":114},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_all(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:312:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m312\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let announcements = sqlx\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________________^\u001b[0m\n\u001b[1m\u001b[94m313\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, title, m\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m314\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.pool)\n\u001b[1m\u001b[94m316\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10459,"byte_end":10469,"line_start":317,"line_end":317,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10459,"byte_end":10469,"line_start":317,"line_end":317,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":10459,"byte_end":10469,"line_start":317,"line_end":317,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:317:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m317\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m317\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10494,"byte_end":10495,"line_start":317,"line_end":317,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10455,"byte_end":10456,"line_start":317,"line_end":317,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10456,"byte_end":10456,"line_start":317,"line_end":317,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:317:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10814,"byte_end":10824,"line_start":327,"line_end":327,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let message = payload[\"message\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"message required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":10814,"byte_end":10824,"line_start":327,"line_end":327,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let message = payload[\"message\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"message required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":10814,"byte_end":10824,"line_start":327,"line_end":327,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let message = payload[\"message\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"message required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:327:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_or((StatusCode::BAD_REQU\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[91m- \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n\u001b[1m\u001b[94m327\u001b[0m \u001b[92m+ \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[91m- \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n\u001b[1m\u001b[94m327\u001b[0m \u001b[92m+ \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10991,"byte_end":11266,"line_start":331,"line_end":337,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"INSERT INTO announcements (id, title, message, priority, created_at, created_by) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, 'human')\")","highlight_start":5,"highlight_end":148},{"text":"        .bind(&id)","highlight_start":1,"highlight_end":19},{"text":"        .bind(title)","highlight_start":1,"highlight_end":21},{"text":"        .bind(message)","highlight_start":1,"highlight_end":23},{"text":"        .bind(priority)","highlight_start":1,"highlight_end":24},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:331:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m331\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"INSERT IN\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m332\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&id)\n\u001b[1m\u001b[94m333\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(title)\n\u001b[1m\u001b[94m334\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(message)\n\u001b[1m\u001b[94m335\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(priority)\n\u001b[1m\u001b[94m336\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m337\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11289,"byte_end":11299,"line_start":338,"line_end":338,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11289,"byte_end":11299,"line_start":338,"line_end":338,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":11289,"byte_end":11299,"line_start":338,"line_end":338,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:338:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m338\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m338\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m338\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m338\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m338\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11324,"byte_end":11325,"line_start":338,"line_end":338,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11285,"byte_end":11286,"line_start":338,"line_end":338,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11286,"byte_end":11286,"line_start":338,"line_end":338,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:338:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m338\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m338\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11366,"byte_end":11562,"line_start":340,"line_end":345,"column_start":24,"column_end":11,"is_primary":true,"text":[{"text":"    let announcement = sqlx::query_as::<_, Announcement>(","highlight_start":24,"highlight_end":58},{"text":"        \"SELECT id, title, message, priority, created_at, created_by FROM announcements WHERE id = ?\"","highlight_start":1,"highlight_end":102},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&id)","highlight_start":1,"highlight_end":15},{"text":"    .fetch_one(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:340:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m340\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let announcement = sqlx\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________^\u001b[0m\n\u001b[1m\u001b[94m341\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, title, \u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m343\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(&id)\n\u001b[1m\u001b[94m344\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_one(&state.pool)\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11581,"byte_end":11591,"line_start":346,"line_end":346,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11581,"byte_end":11591,"line_start":346,"line_end":346,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":11581,"byte_end":11591,"line_start":346,"line_end":346,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:346:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m346\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m346\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11616,"byte_end":11617,"line_start":346,"line_end":346,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11577,"byte_end":11578,"line_start":346,"line_end":346,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11578,"byte_end":11578,"line_start":346,"line_end":346,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:346:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11876,"byte_end":12085,"line_start":356,"line_end":360,"column_start":20,"column_end":11,"is_primary":true,"text":[{"text":"    let activity = sqlx::query_as::<_, ActivityLog>(","highlight_start":20,"highlight_end":53},{"text":"        \"SELECT id, activity_type, agent_id, task_id, description, created_at FROM activity_log ORDER BY created_at DESC LIMIT 50\"","highlight_start":1,"highlight_end":131},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_all(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:356:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m356\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let activity = sqlx::q\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m357\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, activi\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m358\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m359\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.pool)\n\u001b[1m\u001b[94m360\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12104,"byte_end":12114,"line_start":361,"line_end":361,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12104,"byte_end":12114,"line_start":361,"line_end":361,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":12104,"byte_end":12114,"line_start":361,"line_end":361,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:361:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m361\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m361\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m361\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m361\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m361\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12139,"byte_end":12140,"line_start":361,"line_end":361,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":12100,"byte_end":12101,"line_start":361,"line_end":361,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12101,"byte_end":12101,"line_start":361,"line_end":361,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:361:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m361\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m361\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12365,"byte_end":12583,"line_start":370,"line_end":375,"column_start":20,"column_end":11,"is_primary":true,"text":[{"text":"    let activity = sqlx::query_as::<_, TaskActivity>(","highlight_start":20,"highlight_end":54},{"text":"        \"SELECT id, task_id, agent_id, message, timestamp FROM task_activity WHERE task_id = ? ORDER BY timestamp DESC\"","highlight_start":1,"highlight_end":120},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(task_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_all(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:370:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let activity = sqlx::q\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m371\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, task_i\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m372\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m373\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(task_id)\n\u001b[1m\u001b[94m374\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.pool)\n\u001b[1m\u001b[94m375\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12602,"byte_end":12612,"line_start":376,"line_end":376,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12602,"byte_end":12612,"line_start":376,"line_end":376,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":12602,"byte_end":12612,"line_start":376,"line_end":376,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:376:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m376\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m376\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m376\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m376\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m376\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":12637,"byte_end":12638,"line_start":376,"line_end":376,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":12598,"byte_end":12599,"line_start":376,"line_end":376,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12599,"byte_end":12599,"line_start":376,"line_end":376,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:376:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m376\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m376\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13032,"byte_end":13042,"line_start":388,"line_end":388,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let message = payload[\"message\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"message required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13032,"byte_end":13042,"line_start":388,"line_end":388,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let message = payload[\"message\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"message required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":13032,"byte_end":13042,"line_start":388,"line_end":388,"column_start":54,"column_end":64,"is_primary":true,"text":[{"text":"    let message = payload[\"message\"].as_str().ok_or((StatusCode::BAD_REQUEST, \"message required\".to_string()))?;","highlight_start":54,"highlight_end":64}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:388:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m388\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m_or((StatusCode::BAD_REQU\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m388\u001b[0m \u001b[91m- \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n\u001b[1m\u001b[94m388\u001b[0m \u001b[92m+ \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m388\u001b[0m \u001b[91m- \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[91mStatusCode\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n\u001b[1m\u001b[94m388\u001b[0m \u001b[92m+ \u001b[0m    let message = payload[\"message\"].as_str().ok_or((\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::BAD_REQUEST, \"message required\".to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13097,"byte_end":13355,"line_start":390,"line_end":396,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    sqlx::query(\"INSERT INTO task_activity (id, task_id, agent_id, message, timestamp) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\")","highlight_start":5,"highlight_end":128},{"text":"        .bind(&id)","highlight_start":1,"highlight_end":19},{"text":"        .bind(&task_id)","highlight_start":1,"highlight_end":24},{"text":"        .bind(agent_id)","highlight_start":1,"highlight_end":24},{"text":"        .bind(message)","highlight_start":1,"highlight_end":23},{"text":"        .execute(&state.pool)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:390:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m390\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     sqlx::query(\"INSERT IN\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m391\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&id)\n\u001b[1m\u001b[94m392\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(&task_id)\n\u001b[1m\u001b[94m393\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(agent_id)\n\u001b[1m\u001b[94m394\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(message)\n\u001b[1m\u001b[94m395\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .execute(&state.pool)\n\u001b[1m\u001b[94m396\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13378,"byte_end":13388,"line_start":397,"line_end":397,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13378,"byte_end":13388,"line_start":397,"line_end":397,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":13378,"byte_end":13388,"line_start":397,"line_end":397,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:397:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m397\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m397\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m397\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m397\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m397\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13413,"byte_end":13414,"line_start":397,"line_end":397,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":13374,"byte_end":13375,"line_start":397,"line_end":397,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13375,"byte_end":13375,"line_start":397,"line_end":397,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:397:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m397\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m397\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13451,"byte_end":13636,"line_start":399,"line_end":404,"column_start":20,"column_end":11,"is_primary":true,"text":[{"text":"    let activity = sqlx::query_as::<_, TaskActivity>(","highlight_start":20,"highlight_end":54},{"text":"        \"SELECT id, task_id, agent_id, message, timestamp FROM task_activity WHERE id = ?\"","highlight_start":1,"highlight_end":91},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&id)","highlight_start":1,"highlight_end":15},{"text":"    .fetch_one(&state.pool)","highlight_start":1,"highlight_end":28},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:399:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m399\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let activity = sqlx::q\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m400\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id, task_i\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m401\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m402\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(&id)\n\u001b[1m\u001b[94m403\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_one(&state.pool)\n\u001b[1m\u001b[94m404\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13655,"byte_end":13665,"line_start":405,"line_end":405,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13655,"byte_end":13665,"line_start":405,"line_end":405,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":13655,"byte_end":13665,"line_start":405,"line_end":405,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:405:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m405\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m405\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m405\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m405\u001b[0m \u001b[91m- \u001b[0m    .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m405\u001b[0m \u001b[92m+ \u001b[0m    .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13690,"byte_end":13691,"line_start":405,"line_end":405,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":13651,"byte_end":13652,"line_start":405,"line_end":405,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":13652,"byte_end":13652,"line_start":405,"line_end":405,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:405:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m405\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m405\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":13988,"byte_end":14083,"line_start":415,"line_end":417,"column_start":27,"column_end":15,"is_primary":true,"text":[{"text":"    let task_count: i32 = sqlx::query_scalar(\"SELECT COUNT(*) FROM tasks\")","highlight_start":27,"highlight_end":75},{"text":"        .fetch_one(&state.pool)","highlight_start":1,"highlight_end":32},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:415:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m415\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let task_count: i32 = sqlx\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[94m416\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.pool)\n\u001b[1m\u001b[94m417\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14106,"byte_end":14116,"line_start":418,"line_end":418,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14106,"byte_end":14116,"line_start":418,"line_end":418,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":14106,"byte_end":14116,"line_start":418,"line_end":418,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:418:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m418\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m418\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14141,"byte_end":14142,"line_start":418,"line_end":418,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":14102,"byte_end":14103,"line_start":418,"line_end":418,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14103,"byte_end":14103,"line_start":418,"line_end":418,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:418:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14187,"byte_end":14283,"line_start":420,"line_end":422,"column_start":28,"column_end":15,"is_primary":true,"text":[{"text":"    let agent_count: i32 = sqlx::query_scalar(\"SELECT COUNT(*) FROM agents\")","highlight_start":28,"highlight_end":77},{"text":"        .fetch_one(&state.pool)","highlight_start":1,"highlight_end":32},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:420:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m420\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let agent_count: i32 = sqlx\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________________^\u001b[0m\n\u001b[1m\u001b[94m421\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.pool)\n\u001b[1m\u001b[94m422\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14306,"byte_end":14316,"line_start":423,"line_end":423,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14306,"byte_end":14316,"line_start":423,"line_end":423,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":14306,"byte_end":14316,"line_start":423,"line_end":423,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:423:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m423\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m423\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m423\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m423\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m423\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14341,"byte_end":14342,"line_start":423,"line_end":423,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":14302,"byte_end":14303,"line_start":423,"line_end":423,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14303,"byte_end":14303,"line_start":423,"line_end":423,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:423:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m423\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m423\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14386,"byte_end":14503,"line_start":425,"line_end":427,"column_start":27,"column_end":15,"is_primary":true,"text":[{"text":"    let done_count: i32 = sqlx::query_scalar(\"SELECT COUNT(*) FROM tasks WHERE status = 'DONE'\")","highlight_start":27,"highlight_end":97},{"text":"        .fetch_one(&state.pool)","highlight_start":1,"highlight_end":32},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:425:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m425\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let done_count: i32 = sqlx\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[94m426\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.pool)\n\u001b[1m\u001b[94m427\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `StatusCode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14526,"byte_end":14536,"line_start":428,"line_end":428,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":"use of undeclared type `StatusCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14526,"byte_end":14536,"line_start":428,"line_end":428,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::ServerErrorsFailureClass","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":14526,"byte_end":14536,"line_start":428,"line_end":428,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"tower_http::classify::StatusInRangeFailureClass","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `StatusCode`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:428:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m428\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m|e| (StatusCode::INTERNAL\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `StatusCode`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an enum variant `tower_http::classify::ServerErrorsFailureClass::StatusCode` and 1 other; try using the variant's enum\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m428\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m428\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::ServerErrorsFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m428\u001b[0m \u001b[91m- \u001b[0m        .map_err(|e| (\u001b[91mStatusCode\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\u001b[1m\u001b[94m428\u001b[0m \u001b[92m+ \u001b[0m        .map_err(|e| (\u001b[92mtower_http::classify::StatusInRangeFailureClass\u001b[0m::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14561,"byte_end":14562,"line_start":428,"line_end":428,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":14522,"byte_end":14523,"line_start":428,"line_end":428,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14523,"byte_end":14523,"line_start":428,"line_end":428,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:428:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m428\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mr(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m428\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `with` found for struct `Registry` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":759,"byte_end":799,"line_start":38,"line_end":39,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    tracing_subscriber::registry()","highlight_start":5,"highlight_end":35},{"text":"        .with(tracing_subscriber::fmt::layer())","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":799,"byte_end":803,"line_start":39,"line_end":39,"column_start":10,"column_end":14,"is_primary":true,"text":[{"text":"        .with(tracing_subscriber::fmt::layer())","highlight_start":10,"highlight_end":14}],"label":"method not found in `Registry`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lemoreira/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tracing-subscriber-0.3.22/src/layer/mod.rs","byte_start":62363,"byte_end":62367,"line_start":1502,"line_end":1502,"column_start":8,"column_end":12,"is_primary":false,"text":[{"text":"    fn with<L>(self, layer: L) -> Layered<L, Self>","highlight_start":8,"highlight_end":12}],"label":"the method is available for `Registry` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `SubscriberExt` which provides `with` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use tracing_subscriber::prelude::__tracing_subscriber_SubscriberExt;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `with` found for struct `Registry` in the current scope\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:39:10\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m     tracing_subscriber::r\u001b[1m\u001b[94m...\u001b[0m\n  \u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .with(tracing_sub\u001b[1m\u001b[94m...\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `Registry`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0m/home/lemoreira/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tracing-subscriber-0.3.22/src/layer/mod.rs:1502:8\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1502\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       fn with<L>(self, laye\u001b[1m\u001b[94m...\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mthe method is available for `Registry` here\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `SubscriberExt` which provides `with` is implemented but not in scope; perhaps you want to import it\n     \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use tracing_subscriber::prelude::__tracing_subscriber_SubscriberExt;\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 222 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 222 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0425, E0433, E0531, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0282, E0425, E0433, E0531, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}
